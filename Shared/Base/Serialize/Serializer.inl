inline Serializer::Serializer() : m_descriptor(0)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline uint Serializer::count() const
{
	return m_topObjects.count();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline Serializable* Serializer::operator [](uint index) const
{
	ZENIC_ASSERT(index < count());
	return m_topObjects[index];
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::add(Serializable* object)
{
	m_topObjects.pushBack(object);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::remove(Serializable* object)
{
	for (uint i = 0, n = count(); i < n; ++i)
	{
		if (m_topObjects[i] == object)
			m_topObjects.erase(i);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::beginGroup(const char* name, const char* type)
{
	pushGroup(name, type);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::endGroup()
{
	popGroup();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline void Serializer::beginStructure(DataPtr<T>& ptr, const char* name)
{
	// if the structure passed in has not been declared as serialized, this will not compile
	pushStructure(name, T::structure(), reinterpret_cast<Pointer*>(&ptr));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::endStructure()
{
	popStructure();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline Serializer& Serializer::descriptor(const char* descriptor)
{
	m_descriptor = descriptor;
	return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline void Serializer::operator << (T*& object)
{
	// this line will generate a compiler error if passed a non-serializable class
	Serializable* validObject = object;
	validObject = 0;

	process(m_descriptor, reinterpret_cast<Serializable*&>(object));
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (SerializableVersion& version)
{
	process(version);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <class T> inline void Serializer::operator << (SerializableArray<T>& array)
{
	T* values = array.values();

	for (uint i = 0, n = array.count(); i < n; ++i)
		*this << values[i];
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (f32& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (bool& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (s8& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (u8& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (c8& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (s16& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (u16& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (s32& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (u32& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (s64& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Serializer::operator << (u64& v)
{
	process(m_descriptor, v);
	m_descriptor = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline void Serializer::operator << (DataPtr<T>& ptr)
{
	process(m_descriptor, reinterpret_cast<Pointer*>(&ptr), sizeof(T));
}
