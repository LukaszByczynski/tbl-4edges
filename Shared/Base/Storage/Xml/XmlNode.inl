inline const String& XmlNode::value() const
{
	return m_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void XmlNode::setValue(const String& value)
{
	m_value = value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool XmlNode::isEmpty() const
{
	return !m_value.length();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::parent() const
{
	return m_parent;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::firstChild() const
{
	return m_firstChild;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::lastChild() const
{
	return m_lastChild;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::prev() const
{
	return m_prev;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::next() const
{
	return m_next;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlNode* XmlNode::iterate(XmlNode* child) const
{
	if (!child)
		return m_firstChild;

	ZENIC_ASSERT(child->m_parent == m_parent);

	return child->m_next;	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlDocument* XmlNode::document() const
{
	return m_document;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlDocument* XmlNode::toDocument()
{
	return (Document == type()) ? reinterpret_cast<XmlDocument*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlElement* XmlNode::toElement()
{
	return (Element == type()) ? reinterpret_cast<XmlElement*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlComment* XmlNode::toComment()
{
	return (Comment == type()) ? reinterpret_cast<XmlComment*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlUnknown* XmlNode::toUnknown()
{
	return (Unknown == type()) ? reinterpret_cast<XmlUnknown*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlText* XmlNode::toText()
{
	return (Text == type()) ? reinterpret_cast<XmlText*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline XmlDeclaration* XmlNode::toDeclaration()
{
	return (Declaration == type()) ? reinterpret_cast<XmlDeclaration*>(this) : 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void* XmlNode::userData() const
{
	return m_userData;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void XmlNode::setUserData(void* userData)
{
	m_userData = userData;
}
