///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement and may not be copied or disclosed except in
// accordance with the terms of that agreement.
//
// Copyright (c) 2003-2005 Jesper Svennevid, Daniel Collin.
// All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef zenic_ps2_DebugServer_h
#define zenic_ps2_DebugServer_h

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <Shared/Base/Types.h>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{
	namespace ps2
	{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class DebugServer
{
public:

	enum
	{
		MaxCommands = 64
	};

	struct Command
	{
		u16 size;
		u8 buffer[256];
	};

	struct CommandBuffer
	{
		u16 commandCount;
		Command commands[MaxCommands];
	};

	DebugServer();

	bool create();
	void update();

	CommandBuffer& upBuffer();
	CommandBuffer& currentBuffer();

	void setExceedLimit(bool state);
	static DebugServer& instance();

private:

	static void sifCallback(void* packet, void* param);
	static DebugServer* m_instance;

	CommandBuffer m_buffer1;
	CommandBuffer m_buffer2;

	CommandBuffer* m_currentBuffer;
	CommandBuffer* m_upBuffer;
	bool m_exceedLimit;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline DebugServer::CommandBuffer& DebugServer::upBuffer()
{
	return *m_upBuffer;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline DebugServer::CommandBuffer& DebugServer::currentBuffer()
{
	return *m_currentBuffer;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void DebugServer::setExceedLimit(bool state)
{
	m_exceedLimit = state;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline DebugServer& DebugServer::instance()
{
	if (!m_instance)
		m_instance = new DebugServer;

	return *m_instance;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

extern DebugServer* g_debugServer;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	}
}

#endif

