///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement and may not be copied or disclosed except in
// accordance with the terms of that agreement.
//
// Copyright (c) 2005-2006 Jesper Svennevid, Daniel Collin.
// All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef zenic_NetStream_h
#define zenic_NetStream_h

#include <Shared/Base/Types.h>
#include <Shared/Base/Debug/Assert.h>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class NetStream
{
public:

	NetStream();
	NetStream(u8* stream, uint size = 112);
	
	template<class T> void read(T& value);
	const char* readString();

	template<class T> void write(const T& value);
	void writeString(const char* string);
	uint size() const;
	const u8* data() const;
	const u8* startData() const;

	void reset();

private:

	u8* m_data;
	u8* m_startData;
	uint m_dataCount;
	uint m_offset;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline NetStream::NetStream(u8* stream, uint size) :
	m_data(stream),
	m_startData(stream),
	m_dataCount(size),
	m_offset(0)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void NetStream::reset()
{
	m_data = m_startData;
	m_offset = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline void NetStream::read(T& value)
{
	value = *(T*)m_data;
	m_data += sizeof(T);
	m_offset += sizeof(T);
	ZENIC_ASSERT(m_offset < m_dataCount);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline void NetStream::write(const T& value)
{
	*(T*)m_data = value;
	m_data += sizeof(T);
	m_offset += sizeof(T);
	ZENIC_ASSERT(m_offset < m_dataCount);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline uint NetStream::size() const
{
	return m_dataCount;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline const u8* NetStream::data() const
{
	return m_data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline const u8* NetStream::startData() const
{
	return m_startData;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

#endif
