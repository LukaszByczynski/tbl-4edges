#ifndef ps2emu_BufferStream_h
#define ps2emu_BufferStream_h

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Should make it easier if we need to do some endian awareness

#include "datatypes.h"

namespace ps2emu
{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class BufferStream
{
public:
	BufferStream();
	BufferStream(const void* data, u32 size);

	template<class T> T read();

	bool isFinished();
	void setBuffer(const void* data, u32 size);
	void readBuffer(char* dest, uint length);

private:

	const void* m_buffer;
	const void* m_startBuffer;
	const void* m_endBuffer;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BufferStream::BufferStream()
{
	setBuffer(0, 0);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline BufferStream::BufferStream(const void* data, u32 size)
{
	setBuffer(data, size);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BufferStream::setBuffer(const void* data, u32 size)
{
	m_buffer = m_startBuffer = data;
	m_endBuffer = ((u8*)m_buffer) + size;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<class T> inline T BufferStream::read()
{
	T data = ((T*)m_buffer)[0];
	m_buffer = ((T*)m_buffer) + 1;
	
	// TODO: Assert if we read outside the buffer
	
	return data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void BufferStream::readBuffer(char* dest, uint length)
{
	u32* tempDest = reinterpret_cast<u32*>(dest);

	for (uint i = 0; i < length >> 2; ++i)
		*tempDest++ = read<u32>();

	u8* charDest = reinterpret_cast<u8*>(tempDest);

	for (uint i = 0; i < (length & 0x3); ++i)
		*charDest++ = read<u8>();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool BufferStream::isFinished()
{
	return m_buffer >= m_endBuffer;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

#endif