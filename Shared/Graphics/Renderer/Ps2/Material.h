///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement and may not be copied or disclosed except in
// accordance with the terms of that agreement.
//
// Copyright (c) 2005 Jesper Svennevid, Daniel Collin.
// All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef zenic_ps2_Material_h
#define zenic_ps2_Material_h

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <Shared/Graphics/Renderer/Material.h>
#include <Shared/Geometry/Ps2/Texture.h>
#include <Shared/Base/Math/Color32.h>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{
	namespace ps2
	{
		class Dma;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{
	namespace ps2
	{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Material : public zenic::Material
{
	ZENIC_SERIALIZABLE_FACTORY;

public:

	Material();
	~Material();
	void execute(Dma& dmaChain);
	void serialize(Serializer& s);

	void setBaseTexture(Texture& texture);
	const Texture& baseTexture() const;

	bool glow() const;
	void setGlow(bool glow);

	bool additive() const;
	void setAdditive(bool additive);

	Color32 color() const;
    void setColor(Color32 color);

	u16 transValue() const;
	void setTransValue(u16 transValue);

private:

	Texture m_texture;
	Color32 m_color;
	bool m_glow;
	bool m_additive;
	u16 m_transValue;
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Material::setBaseTexture(Texture& texture)
{
	m_texture = texture;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline const Texture& Material::baseTexture() const
{
	return m_texture;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool Material::glow() const
{
	return m_glow;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Material::setGlow(bool glow)
{
	m_glow = glow;
}
 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline bool Material::additive() const
{
	return m_additive;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Material::setAdditive(bool additive)
{
	m_additive = additive;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline Color32 Material::color() const
{
	return m_color;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Material::setColor(Color32 color)
{
	m_color = color;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline u16 Material::transValue() const
{
	return m_transValue;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

inline void Material::setTransValue(u16 transValue)
{
	m_transValue = transValue;
}
 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif

