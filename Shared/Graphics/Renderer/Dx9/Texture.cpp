///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement and may not be copied or disclosed except in
// accordance with the terms of that agreement.
//
// Copyright (c) 2003-2005 Jesper Svennevid, Daniel Collin.
// All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// includes
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "Texture.h"

#include <Shared/Base/Serialize/Serializer.h>
#include <Shared/Base/Serialize/SerializableVersion.h>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// class
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{

namespace win32
{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ZENIC_CREATE_SERIALIZABLE_FACTORY(Texture, SERIALIZABLE_ID('D','X','9','R'), SERIALIZABLE_ID('T','X','T','R'));

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Texture::setSurfaces( u32 surfaces )
{
	if( surfaces < m_surfaces.count() )
	{
		for( uint i = surfaces; i < m_surfaces.count(); ++i )
			m_surfaces[i].data().free();
	}

	m_surfaces.resize( surfaces );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Texture::serialize( Serializer& s )
{
	SerializableVersion version(1,factory());
	s << version;

	s.descriptor(SERIALIZER_NAME("m_width")) << m_width;
	s.descriptor(SERIALIZER_NAME("m_height")) << m_height;
	s.descriptor(SERIALIZER_NAME("m_depth")) << m_depth;
	s.descriptor(SERIALIZER_NAME("m_format")) << m_format;
	s.descriptor(SERIALIZER_NAME("m_properties")) << m_properties;

	s.beginStructure(m_surfaces,SERIALIZER_NAME("m_surfaces"));
	for( uint i = 0; i < m_surfaces.count(); ++i )
		m_surfaces[i].serialize(s);
	s.endStructure();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Texture::Surface::serialize( Serializer& s )
{
	s.descriptor(SERIALIZER_NAME("m_pitch")) << m_pitch;
	s.descriptor(SERIALIZER_NAME("m_data")) << m_data;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}

}
