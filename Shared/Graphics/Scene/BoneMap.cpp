///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement and may not be copied or disclosed except in
// accordance with the terms of that agreement.
//
// Copyright (c) 2003-2005 Jesper Svennevid, Daniel Collin.
// All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "BoneMap.h"

#include <Shared/Base/Serialize/Serializer.h>
#include <Shared/Base/Serialize/SerializableVersion.h>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace zenic
{

ZENIC_CREATE_SERIALIZABLE_FACTORY(BoneMap, SERIALIZABLE_ID('Z','N','I','C'), SERIALIZABLE_ID('B','M','A','P'))
ZENIC_CREATE_SERIALIZABLE_STRUCTURE(BoneMap,Index,SERIALIZABLE_ID('I','N','D','X'))

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO: move this to inline

BoneMap::~BoneMap()
{
	m_bones.free();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void BoneMap::serialize(Serializer& s)
{
	SerializableVersion version(1, factory());

	s << version;

	s.descriptor(SERIALIZER_NAME("m_affected")) << m_affected;

	s.beginStructure(m_bones,SERIALIZER_NAME("m_bones"));
	for (uint i = 0, n = m_bones.count(); i < n; ++i)
		s << m_bones[i].m_index;
	s.endStructure();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}
